#### คำถาม 1: การเปรียบเทียบโครงสร้าง (5 คะแนน)

**ก. จำนวนบรรทัดโค้ดและไฟล์**

สร้างตารางเปรียบเทียบ:

| ข้อมูล | Monolithic (Week 3) | Layered (Week 4) |
|--------|---------------------|------------------|
| จำนวนไฟล์ JS หลัก | 2 | 10 |
| จำนวนบรรทัดทั้งหมด | 644 | 1107 |
| จำนวน layers | 1 | 3 |
| ความซับซ้อนโดยรวม | 1 | 3|

**คำถาม:**
1. Layered มีจำนวนไฟล์และบรรทัดโค้ดมากกว่าหรือน้อยกว่า Monolithic? เพราะอะไร?
```
เพราะ Layered แยกการทำงานออกเป็นหลายๆไฟล์เพื่อทำน้าที่เฉพาะรวมถึงเชื่อระหว่าง layeres
แต่ Monolithic รวมทุกหน้าที่ไว้ในไฟล์เดียวทำให้มีโค๊ดและไฟล์น้อยกว่า
```
3. ความซับซ้อนที่เพิ่มขึ้นคุ้มค่าหรือไม่? อธิบาย
```
คุ้มค่าในงานขนาดกลาง-ใหญ่ หรือทำงานเป็นทีม เพราะง่ายต่อการดูแล รักษา ขยาย
```

#### คำถาม 2: จุดแข็ง-จุดอ่อน (10 คะแนน)

**วิเคราะห์จุดแข็งของ Layered Architecture:**

สร้างตารางวิเคราะห์:

| Quality Attribute | Monolithic | Layered | คะแนน (1-5) | อธิบายเหตุผล |
|-------------------|------------|---------|--------|-------------|
| **Maintainability** | 1 | 5 | 5 | Layered แยกหน้าที่ชัดเจน ทำให้เมื่อระบบขยายใหญ่ขึ้น การแก้ไขโค้ดจะไม่กระทบส่วนอื่นโดยไม่ตั้งใจ |
| **Testability** | 1 | 5 | 4 | Layered สามารถทำ Unit Test เฉพาะ Service หรือ Repository ได้โดยไม่ต้องรัน Server |
| **Modifiability** | 1 | 5 | 5 | การเปลี่ยน Business Logic ใน Layered ทำได้ที่ Service Layer เพียงจุดเดียว |
| **Reusability** | 1 | 5 | 5 | Repository และ Service ใน Layered สามารถนำไปใช้ซ้ำกับ Controller อื่นๆ ได้ทันที |
| **Team Collaboration** | 2 | 5 | 5 | แยกไฟล์ตามหน้าที่ ทำให้ทีมพัฒนาหลายคนทำงานพร้อมกันได้โดยไม่เกิด Merge Conflict |
| **Performance** | 5 | 4 | 4 | Monolithic เร็วกว่าเล็กน้อยเพราะไม่มี Overhead จากการส่งต่อข้อมูลผ่านหลายชั้นของโค้ด |
| **Simplicity** | 5 | 2 | 2 | Monolithic ง่ายกว่ามากสำหรับผู้เริ่มต้นและโปรเจกต์ขนาดเล็ก |

**คำแนะนำ:**
- ให้คะแนน 1-5 (1 = แย่ที่สุด, 5 = ดีที่สุด)
- อธิบายเหตุผลอย่างละเอียด โดยยกตัวอย่างจากโค้ดจริง
- เปรียบเทียบว่าส่วนไหนของโค้ดทำให้ดีขึ้นหรือแย่ลง

#### คำถาม 3: สถานการณ์จริง (5 คะแนน)

**วิเคราะห์สถานการณ์ต่อไปนี้:**

**สถานการณ์ที่ 1:** ต้องการเพิ่มฟีเจอร์ "assign task to user"
- ใน Monolithic จะต้องแก้ไขอย่างไร?
- ใน Layered จะต้องแก้ไขอย่างไร?
- แบบไหนง่ายกว่า? เพราะอะไร?

**คำตอบของคุณ:**
```
- Monolithic: ต้องเพิ่มโค้ดทั้งส่วนรับค่า, ตรวจสอบ, และบันทึกลงฐานข้อมูลใน Route เดียวกัน ทำให้ไฟล์ server.js ยาวและซับซ้อนขึ้นมาก
- Layered: เพิ่ม Method ใน Repository สำหรับ Update, เพิ่ม Logic ใน Service และสร้าง Endpoint ใน Controller
- สรุป: Layered ง่ายกว่าในระยะยาวเพราะโค้ดถูกจัดวางเป็นระเบียบ แต่ Monolithic จะเขียนโค้ดเสร็จเร็วกว่าในตอนแรก
```

**สถานการณ์ที่ 2:** มีบั๊กที่ validation logic (ตรวจสอบ title)
- ใน Monolithic จะต้องหาบั๊กและแก้ไขที่ไหน?
- ใน Layered จะต้องหาบั๊กและแก้ไขที่ไหน?
- แบบไหนง่ายกว่า? เพราะอะไร?

**คำตอบของคุณ:**
```
- Monolithic: ต้องไล่หาโค้ดในไฟล์ server.js ขนาดใหญ่ที่ปะปนอยู่กับโค้ดส่วนอื่นๆ
- Layered: พุ่งเป้าไปที่ Service Layer ได้ทันที เพราะเป็นส่วนที่จัดการ Business Logic และ Validation
- สรุป: Layered ง่ายกว่า เพราะขอบเขตของบั๊กถูกจำกัดไว้ในชั้นที่ชัดเจน
```

**สถานการณ์ที่ 3:** ต้องการเปลี่ยนจาก SQLite เป็น PostgreSQL
- ใน Monolithic จะต้องแก้ไขกี่ที่?
- ใน Layered จะต้องแก้ไขกี่ที่?
- แบบไหนง่ายกว่า? เพราะอะไร?

**คำตอบของคุณ:**
```
- Monolithic: ต้องไล่แก้คำสั่ง SQL ที่กระจายอยู่ทั่วไฟล์ server.js
- Layered: แก้ไขเฉพาะใน Repository Layer เพียงที่เดียว ส่วน Service และ Controller ไม่ต้องเปลี่ยนโค้ดเลย
- สรุป: Layered ง่ายกว่าอย่างชัดเจน เพราะแยกส่วนการเข้าถึงข้อมูล (Data Access) ออกจากส่วนอื่น
```

#### คำถาม 4: Trade-offs (5 คะแนน)

**วิเคราะห์ Trade-offs:**

1. **Complexity vs Maintainability**
   - Layered มีความซับซ้อนมากขึ้น แต่ดูแลง่ายขึ้น
   - คุณคิดว่า trade-off นี้คุ้มค่าหรือไม่? เพราะอะไร?
   - ในกรณีไหนที่คุ้มค่า? ในกรณีไหนที่ไม่คุ้มค่า?

**คำตอบของคุณ:**
```
ผมคิดว่าคุ้มค่ามากครับ เพราะแม้ตอนแรกเราต้องเสียเวลาสร้างไฟล์เยอะ (Repository, Service, Controller) ทำให้โครงสร้างดูซับซ้อนขึ้น 
แต่พอระบบเริ่มใหญ่ขึ้น การมีระเบียบแบบนี้ช่วยให้เวลาเกิดบั๊กเราพุ่งเป้าไปแก้ได้ถูกจุดโดยไม่ไปกระทบส่วนอื่น

- กรณีที่คุ้มค่า: โปรเจกต์ที่ต้องพัฒนาต่อเรื่อยๆ, ระบบที่มี Business Logic ซับซ้อน หรือการทำงานเป็นทีม
- กรณีที่ไม่คุ้มค่า: งานด่วนขนาดเล็ก (Prototype), โปรเจกต์ที่ทำครั้งเดียวทิ้ง หรือระบบที่มีแค่การดึงข้อมูลแสดงผลเฉยๆ ไม่มีการประมวลผลอะไร
```

2. **Performance Overhead**
   - Layered มี overhead จากการเรียกผ่าน layers
   - คุณคิดว่ามีผลกระทบมากแค่ไหน?
   - ในแอปพลิเคชันประเภทใดที่ performance overhead นี้สำคัญ?

**คำตอบของคุณ:**
```
จากที่ทดสอบรันดู ผมคิดว่าแทบไม่มีผลกระทบต่อผู้ใช้ทั่วไปเลยครับ เพราะการเรียกฟังก์ชันข้ามไฟล์ (Layer) 
กินเวลาเพิ่มขึ้นน้อยมากจนมองด้วยตาเปล่าไม่เห็น (ระดับมิลลิวินาที) เมื่อเทียบกับเวลาที่เสียไปกับการดึงข้อมูลจาก Database

Performance overhead นี้จะสำคัญในแอปพลิเคชันประเภท:
- ระบบ Real-time สูงๆ เช่น การเทรดหุ้น (High-frequency trading) 
- ระบบประมวลผลข้อมูลมหาศาล (Big Data processing) 
- หรือระบบที่ต้องการความเร็วระดับเสี้ยววินาทีจริงๆ เช่น เกมออนไลน์
```

#### คำถาม 5: การตัดสินใจเลือกใช้ (5 คะแนน)

**ออกแบบกฎการตัดสินใจ:**

สร้าง Decision Tree สำหรับตัดสินใจว่าจะใช้ Monolithic หรือ Layered:

```
เริ่มต้นโปรเจกต์
│
├─ ขนาดทีม?
│  ├─ 1-2 คน → [Monolithic]
│  └─ 3+ คน → [Layered]
│
├─ ขนาดโปรเจกต์?
│  ├─ เล็ก (< 1000 บรรทัด) → [Monolithic]
│  ├─ กลาง (1000-10000 บรรทัด) → [Layered]
│  └─ ใหญ่ (> 10000 บรรทัด) → [Layered/Client-Server]
│
├─ ระยะเวลาพัฒนา?
│  ├─ ต้องการเร็ว (< 1 เดือน) → [Monolithic]
│  └─ มีเวลา (> 1 เดือน) → [Layered]
│
└─ ต้องการ maintainability สูง?
   ├─ ใช่ → [Layered]
   └─ ไม่ → [Monolithic]
```

**อธิบายเหตุผลของการตัดสินใจแต่ละข้อ:**
```
- การเลือก Monolithic เหมาะกับงานที่เน้นความเร็วและทรัพยากรบุคคลจำกัด
- การเลือก Layered เหมาะกับงานที่เน้นคุณภาพของซอฟต์แวร์ การทำงานร่วมกัน และการขยายระบบในระยะยาว
```

---
